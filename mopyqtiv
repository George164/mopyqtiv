#!/usr/bin/env python3
# -*- coding: utf-8 -*-

##########################################################################
# Copyright [2016] [Евгений]
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
##########################################################################

import os  # операции с файлами
import sys  # аргументы командной строки
import time  # для меток удаляемых файлов
import math  # для расчёта размеров графической сцены
import shutil  # для удаления файлов
import atexit  # для удаления временных файлов при выходе
import hashlib  # для рандомных имён времнных папок

from PIL import Image
from multiprocessing import Pool, Pipe

from PyQt5.QtGui import (QIcon, QPalette, QColor,
                         QFont, QPixmap, QCursor, QTransform,
                         QBrush
                         )

from PyQt5.QtWidgets import (QWidget, QMenu, QLabel, QScrollArea,
                             QApplication, QFileDialog, QAction,
                             QVBoxLayout, QLayout, QInputDialog, qApp,
                             QGraphicsPixmapItem, QGraphicsScene,
                             QGraphicsView
                             )

from PyQt5.QtCore import (Qt, QThread, QFileInfo, QTimer,
                          pyqtSignal, pyqtSlot)

from PyQt5.QtOpenGL import QGLWidget

###################################################
############### EDIT VARIABLES HERE ###############

WITHOUT_BORDER = True  # главное окно без рамки, рекомендуется
HINT_TIME = 2.5  # время показа сообщений в секундах
SCALE_STEP = 0.8  # шаг изменения масштаба
ROTATE_STEP = 5  # шаг вращения изображения в градусах
SCALE_MAGNIFIER = 1.8  # масштаб для лупы
MAGNIFIER_MOVE_BOOST = 1.5  # ускорение перемещния в режиме лупы
MINIATURE_WIDTH = 250  # ширина миниатюры по умолчанию
BACKGROUND_COLOR = '#000000'  # цвет фона главного окна
COPY_ON_SORTING = False  # перемещение (False) или копирование (True) при сортировке
USE_OPENGL = False  # использовать OpenGL для центрального виджета

########### DO NOT EDIT AFTER THIS LINE ###########
###################################################


class Filer:
    """
    Этот класс создаёт и обновляет список файлов
    """

    def __init__(self):
        self.files = []
        self.current_folder = os.getcwd()  # запись текущей папки
        self.dialog = QFileDialog()  # диалог выбора файлов
        self.can_choose_file = True
        self.available_extensions = ('.bmp', '.pbm', '.pgm', '.ppm', '.xbm',
                                     '.xpm', '.jpg', '.jpeg', '.png', '.gif'
                                     )

    def list_folder(self, path):
        """
        создаёт список изобр. папки -> self.files
        """
        self.files = []  # очистка списка изображений
        for name in os.listdir(path):
            # фильтр по расширению
            if os.path.splitext(name)[1].lower() in self.available_extensions:
                self.files.append(os.path.join(path, name))
        self.files = list(set(self.files))  # не допускает дубликатов
        self.files.sort()

    def choose_file(self):
        """
        Диалог выбора картинки: возвращает путь для выбранного файла
        """
        if self.can_choose_file is True:
            file_path = self.dialog.getOpenFileName(
                    parent=None,
                    caption='Выбор файла изображения',
                    directory=self.current_folder,
                    filter='Изображения('
                           '*.bmp *.pbm *.pgm *.ppm *.xbm '
                           '*.xpm *.jpg *.jpeg *.png *.gif)'
            )[0]

            # обновление текущей папки
            self.current_folder = os.path.split(file_path)[0]

            return file_path

        else:
            return ''

    def choose_folder(self, folder):
        """
        Диалог выбора папки: возвращает полный путь
        """
        folder_path = self.dialog.getExistingDirectory(
                parent=None,
                caption='Выбор папки для сортировки',
                directory=folder
        )

        return folder_path


class Bind:
    """
    Объект временной связи клавиша -> папка
    Используется для сортировки изображений
    """

    def __init__(self):
        self.key = ''
        self.path = ''

    def move(self, image_path):
        """
        Отправляет изображение image_path по адресу destination
        В зависимости от настройки копирует или перемещает
        """
        destination = os.path.join(self.path, os.path.split(image_path)[1])

        # перемещение или копирование при сортировке
        if COPY_ON_SORTING is False:
            shutil.move(image_path, destination)
        else:
            shutil.copy(image_path, destination)


class PopupMenu(QMenu):
    """
    Всплывающее меню
    """

    def __init__(self, main):
        super().__init__()

        self.main = main
        self.file = ''

        # описание действий
        info_action = QAction(
                QIcon.fromTheme('exifinfo'),
                'Информация',
                self
        )

        rename_action = QAction(
                QIcon.fromTheme('edit-rename'),
                'Переименовать',
                self
        )

        turn_right_action = QAction(
                QIcon.fromTheme('object-rotate-right'),
                'Повернуть вправо',
                self
        )

        turn_left_action = QAction(
                QIcon.fromTheme('object-rotate-left'),
                'Повернуть влево',
                self
        )

        trash_action = QAction(
                QIcon.fromTheme('trash-empty'),
                'Отправить в корзину',
                self
        )

        exit_action = QAction(
                QIcon.fromTheme('application-exit'),
                'Выход',
                self
        )

        info_action.triggered.connect(self.show_info)
        rename_action.triggered.connect(self.rename_img)
        turn_right_action.triggered.connect(lambda: self.main.turn_right(self.file))
        turn_left_action.triggered.connect(lambda: self.main.turn_left(self.file))
        trash_action.triggered.connect(lambda: self.main.trash(self.file))
        exit_action.triggered.connect(sys.exit)

        # сборка выпадающего меню
        self.addAction(info_action)
        self.addAction(rename_action)
        self.addSeparator()
        self.addAction(turn_right_action)
        self.addAction(turn_left_action)
        self.addSeparator()
        self.addAction(trash_action)
        self.addSeparator()
        self.addAction(exit_action)

    def show_info(self):
        """
        Показывает краткую информацию по файлу
        """
        file_name = os.path.split(self.file)[1]
        pixmap = QPixmap(self.file)
        width = pixmap.width()
        height = pixmap.height()
        size = self.file_size()

        self.main.info.show_hint(
                '«{0}»: разрешение <font color="red"><b>{1}x{2}</b></font>, '
                'размер <font color="red"><b>{3}</b></font> {4}'.format(
                        file_name,
                        width,
                        height,
                        size[0],
                        size[1]
                )
        )

    def file_size(self):
        """
        Возвращает удобочитаемый размер файла
        """
        file = QFileInfo(self.file)
        size = file.size()

        if size < 1024:
            return str(size), 'байт'

        elif 1024 <= size < 1048576:
            return str(round(size / 1024, 1)), 'Кб'

        else:
            return str(round(size / 1048576, 1)), 'Мб'

    def rename_img(self):
        """
        Показывает диалог для переименовывания файла
        """
        file_name = os.path.split(self.file)[1]
        text, accepted = QInputDialog.getText(self,
                                              "Переименовывание файла",
                                              "Введите новое имя файла",
                                              text=file_name
                                              )
        if accepted and text > '':
            new_file_path = os.path.join(os.path.split(self.file)[0], text)

            # переименовывание файла оригинала
            shutil.move(self.file, new_file_path)

            # корректировка списка файлов
            for i, file in enumerate(self.main.filer.files):
                if file == self.file:
                    self.main.filer.files[i] = new_file_path

            # корректировка виджета миниатюры
            for miniature in self.main.miniatures_handler.list_miniatures_widgets():
                if miniature.original_file == self.file:
                    miniature.original_file = new_file_path

            self.main.current_image = new_file_path


class InfoLabel(QLabel):
    """
    Используется для показа сообщений в левом нижнем углу экрана
    """

    def __init__(self, main):
        super().__init__()

        self.main = main
        self.setMargin(5)
        self.resize(50, 30)
        self.move(40, self.main.frame_resolution_height - 60)
        self.setWindowFlags(Qt.WindowStaysOnTopHint |
                            Qt.FramelessWindowHint |
                            Qt.X11BypassWindowManagerHint)
        self.setMaximumWidth(main.frame_resolution_width - 80)

        self.font = QFont()
        self.font.setFamily('Liberation Serif')
        self.font.setPointSize(14)
        self.font.setItalic(True)
        self.setFont(self.font)

    def show_hint(self, text):
        """
        Показывает сообщение text
        """
        self.timer = QTimer()
        self.timer.setInterval(HINT_TIME * 1000)
        self.timer.timeout.connect(self.close_hint)
        self.setText(text)
        self.adjustSize()
        self.show()
        self.timer.start()

    def close_hint(self):
        """
        Выполняется при завершении работы таймера self.timer
        """
        self.hide()
        self.timer.deleteLater()
        self.close()


class Miniature(QLabel):
    """
    Отдельно взятая миниатюра с переписанными событиями щелчка мышью
    """

    def __init__(self, main):
        super().__init__()
        self.main = main

        self.path = ''
        self.original_file = ''

        # настройка выпадающего меню
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.context_menu)

    def mousePressEvent(self, event):
        """
        Установка картинки по щелчку на миниатюре
        """
        if event.button() == Qt.LeftButton:
            self.main.current_image = self.original_file
            self.main.imageviewer.set_image(self.main.current_image,
                                            self.main.imageviewer.scale_default
                                            )

    def context_menu(self, point):
        """
        Вызвает выпадающее меню
        """
        self.main.popup.file = self.original_file
        self.main.popup.exec_(QCursor.pos())


class MiniaturesFolderHandler:
    """
    Создаёт/обновляет/удаляет временную папку для миниатюр
    """

    def __init__(self):
        self.folder = '/tmp/mopyqtiv.' + hashlib.sha1(os.urandom(8)).hexdigest()[:8]
        self.create_folder()

    def create_folder(self):
        """
        Удаляет старую и создаёт новую папку для миниатюр
        """
        self.remove_miniatures_folder()
        os.mkdir(self.folder)

    def remove_miniatures_folder(self):
        """
        Удаляет все относящиеся к программе временные папки в /tmp
        """
        for name in os.listdir('/tmp'):
            if 'mopyqtiv' in name:
                shutil.rmtree(os.path.join('/tmp', name))


class MiniaturesMaker:
    """
    Создаёт миниатюры для всех файлов в папке
    """

    def __init__(self):
        self.conn = first
        self.files = []
        self.folder = ''

    def make_one_miniature(self, index_and_file):
        """
        Создаёт одну миниатюру во временной папке
        """
        index = index_and_file[0]
        file_path = index_and_file[1]
        miniature_path = os.path.join(
                self.folder,
                os.path.split(file_path)[1]
        )

        try:
            with Image.open(file_path) as miniature:
                width = MINIATURE_WIDTH
                ratio = width / miniature.size[0]
                height = miniature.size[1] * ratio
                miniature.thumbnail((width, height), Image.ANTIALIAS)
                miniature.save(miniature_path)

                # отправка сообщения о готовности миниатюры
                self.conn.send(['DONE', index, file_path, miniature_path])

        except EnvironmentError or OSError:
            return

    def create_miniatures(self):
        """
        Запуск распараллеленного создания миниатюр
        """
        # индексирует входящие файлы
        self.files = enumerate(self.files)

        pool = Pool()
        pool.map(self.make_one_miniature, self.files)
        pool.close()
        pool.join()

        # отправка сообщения о том, что все миниатюры сделаны
        self.conn.send('STOP')


class MiniaturesMakerThread(QThread):
    """
    Управляет созданием миниатюр в отдельном потоке
    """

    def __init__(self, main):
        super().__init__()
        self.main = main

    def run(self):
        self.main.miniatures_handler.miniatures_maker.files = self.main.filer.files
        self.main.miniatures_handler.miniatures_maker.folder = \
            self.main.miniatures_handler.miniatures_folder_handler.folder
        self.main.miniatures_handler.miniatures_maker.create_miniatures()

        # теперь можно выбирать изображения
        self.main.filer.can_choose_file = True


class MiniaturesSetter(QThread):
    """
    Слушает сообщения о готовых миниатюрах
    и отправляет сигнал на установку
    """

    minidone = pyqtSignal(int, str, str, name='MiniatureDone')

    def __init__(self, main):
        super().__init__()
        self.main = main
        self.conn = second

    def run(self):
        while True:
            message = self.conn.recv()
            # когда все миниатюры в папке созданы
            if message == 'STOP':
                break

            # добавляет миниатюру в очередь
            if message[0] == 'DONE':
                done = (message[1], message[2], message[3])
                # выслать в сигнале: порядковый индекс виджета  done[0]
                #                    путь до ориг. файла:       done[1]
                #                    путь до миниатюры:         done[2]
                self.minidone.emit(done[0], done[1], done[2])


class MiniaturesArea(QWidget):
    """
    На этом виджете будут располагаться виджеты миниматюр
    """

    def __init__(self, main):
        super().__init__()
        self.main = main

        # настройка раскладки
        self.miniatures_layout = QVBoxLayout(self)
        self.miniatures_layout.setSizeConstraint(QLayout.SetFixedSize)
        self.setLayout(self.miniatures_layout)


class MiniaturesScroller(QScrollArea):
    """
    Этот класс добавляет область прокрутки на панель миниатюр
    """

    def __init__(self, main):
        super().__init__(main)

        # наложение прокрутки
        self.miniatures_area = main.miniatures_area
        self.setWidget(self.miniatures_area)

        # чтобы работали стрелки
        self.setFocusPolicy(Qt.NoFocus)

        # настройка внешнего вида
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)


class MiniaturesHandler:
    """
    Управляет подготовкой, созданием, изменением размера, удалением миниатюр
    """

    def __init__(self, main):
        self.main = main
        self.miniatures_layout = self.main.miniatures_area.miniatures_layout

        # создание объектов обработки миниатюр
        self.miniatures_maker = MiniaturesMaker()
        self.miniatures_maker_thread = MiniaturesMakerThread(main)
        self.miniatures_to_queue = MiniaturesSetter(main)
        self.miniatures_folder_handler = MiniaturesFolderHandler()

        # настройка связи между потоками
        self.miniatures_maker_thread.started.connect(self.miniatures_to_queue.start)
        self.miniatures_to_queue.minidone.connect(self.set_one_miniature)

    def set_miniatures(self):
        """
        Запускает цикл создания миниатюр
        """
        self.miniatures_maker_thread.start()

    @pyqtSlot(int, str, str, name='MiniatureDone')
    def set_one_miniature(self, index, file_path, miniature_path):
        """
        Создаёт и устанавливает одну миниатюру
        """
        miniature = Miniature(self.main)
        miniature.path = miniature_path
        miniature.original_file = file_path
        miniature.image = QPixmap(miniature_path)
        # поправка на изменённый размер окна self.main.coefficient
        miniature_width = MINIATURE_WIDTH * self.main.coefficient
        miniature_height = miniature_width / miniature.image.width() * \
                           miniature.image.height()

        miniature.setPixmap(
                miniature.image.scaled(
                        miniature_width,
                        miniature_height,
                        Qt.KeepAspectRatio,
                        Qt.FastTransformation
                )
        )

        self.main.miniatures_area.miniatures_layout.insertWidget(index, miniature)

    def resize_miniatures(self, coefficient):
        """
        Изменяет размер всех виджетов миниатюр с сохранением пропорций
        в зависимости от полученного коэффициента
        """
        for miniature in self.list_miniatures_widgets():
            miniature_width = MINIATURE_WIDTH * coefficient
            miniature_height = miniature.image.height() * coefficient
            miniature.resize(miniature_width,
                             miniature_height
                             )

            miniature.setPixmap(
                    miniature.image.scaled(miniature_width,
                                           miniature_height,
                                           Qt.KeepAspectRatio,
                                           Qt.FastTransformation
                                           )
            )

    def list_miniatures_widgets(self):
        """
        Возвращает список виджетов миниатюр
        """
        miniatures_widgets = (
            self.miniatures_layout.itemAt(i).widget()
            for i in range(self.miniatures_layout.count())
        )

        return miniatures_widgets

    def purge_miniature(self, file_for_delete):
        """
        Удаляет виджет миниатюры переданного файла
        """
        for miniature in self.list_miniatures_widgets():
            if miniature.original_file == file_for_delete:
                # попытка удаления миниатюры
                try:
                    os.remove(miniature.path)
                # если файла миниатюры нет
                except FileNotFoundError or OSError:
                    pass

                # удаление виджета миниатюры
                miniature.deleteLater()

        # если удаляется последнее в папке изображение
        if self.miniatures_layout.count() == 1:
            print('mopyqtiv: изображений в папке больше нет')
            sys.exit(0)

    def purge_all_miniatures(self):
        """
        Удаление всех виджетов миниатюр
        """
        for miniature in self.list_miniatures_widgets():
            miniature.deleteLater()
        self.main.miniatures_handler.miniatures_folder_handler.create_folder()

    def turn_miniature(self, image_path, degree):
        """
        Вращает и обновляет миниатюру переданного файла вправо,
        в зависимости от параметра degree
        """
        for miniature in self.list_miniatures_widgets():
            if miniature.original_file == image_path:
                self.main.turn_image(miniature.path, degree)
                miniature.image.load(miniature.path)

                # расчёт нового размера миниатюры
                miniature_width = MINIATURE_WIDTH * self.main.coefficient
                miniature_height = MINIATURE_WIDTH / miniature.image.width() * \
                           miniature.image.height()
                miniature.setPixmap(
                        miniature.image.scaled(miniature_width,
                                               miniature_height,
                                               Qt.KeepAspectRatio,
                                               Qt.FastTransformation
                                               )
                )


class ImageViewer(QGraphicsView):
    """
    Центральный виджет просмотрщика изображений
    """

    def __init__(self, main):
        super().__init__(main)

        self.main = main  # для обращений к классу главного окна
        self.ratio = 0  # отношения сторон картинки
        self.rotation = 0  # запись текущего угла повората картинки
        self.is_scaled = False
        self.is_magnified = False
        self.scale_default = 1.0
        self.current_scale = 1.0  # текущий коэффициент масштаба
        self.current_pixmap = QPixmap()  # pixmap текущего изображения
        self.current_pixmap.path = ''  # для запись пути текущей картинки
        self.current_img_width = 0
        self.current_img_height = 0

        # настройка сцены
        self.transform = QTransform()
        self.brush = QBrush(self.main.background_color)
        self.img_scene = QGraphicsScene()
        self.img_scene.setBackgroundBrush(self.brush)
        self.img_item = QGraphicsPixmapItem()
        self.img_scene.addItem(self.img_item)
        self.setScene(self.img_scene)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setAlignment(Qt.AlignCenter)

        # на любителя: OpenGL
        if USE_OPENGL is True:
            self.setViewport(QGLWidget())

        # настройка управления
        self.setMouseTracking(True)
        self.setFocusPolicy(Qt.NoFocus)

        # для комбинаций кнопок мыши
        self.lb_held = False
        self.rb_held = False
        self.rb_combined = False

    def set_image(self, image_path, scale):
        """
        Используется для установки/обновления изображения на центральном виджете
        """
        # для избежания повторной подгрузки изображения
        if self.current_pixmap.path != image_path \
                or self.main.is_image_altered is True:
            self.current_pixmap = QPixmap(image_path)
            self.main.is_image_altered = False
            self.set_img_center()
            self.rotation = 0

            # запись пути файла к текущему pixmap
            self.current_pixmap.path = image_path

            # проверка читаемости картинки
            if self.check_pixmap(self.current_pixmap) is False:
                return

        # запись размера текущей картинки в полную величину
        self.current_img_width = self.current_pixmap.width()
        self.current_img_height = self.current_pixmap.height()

        # сброс коэффициента масштабирования
        self.ratio = 1.0

        # подгонка размеров изображения под габариты окна,
        if self.is_current_scale_bigger_than_frame() is True:
            # если картинка растянута по ширине более, чем окно
            if self.current_img_width / self.current_img_height > self.main.frame_ratio():
                self.ratio = self.main.frame_resolution_width / self.current_img_width
                self.current_img_width = self.main.frame_resolution_width
                self.current_img_height = self.current_img_height * self.ratio

            # если картинка растянута по высоте более, чем окно
            else:
                self.ratio = self.main.frame_resolution_height / self.current_img_height
                self.current_img_height = self.main.frame_resolution_height
                self.current_img_width = self.current_img_width * self.ratio

        if scale != 1.0:  # если применяется масштаб
            self.current_img_width *= scale
            self.current_img_height *= scale
            self.current_scale = scale
            self.ratio *= scale
            if self.is_magnified is False:
                self.is_scaled = True

        if scale == self.scale_default:  # если масштаб не применяется
            self.is_scaled = False
            self.is_magnified = False
            self.current_scale = self.scale_default

        self.img_item.setPixmap(
                self.current_pixmap.scaled(self.current_img_width,
                                           self.current_img_height,
                                           Qt.KeepAspectRatio,
                                           Qt.SmoothTransformation
                                           )
        )

        self.rotate_widget(0)
        self.main.change_title(os.path.split(self.main.current_image)[1])

    def set_img_center(self):
        hscroll_min = self.horizontalScrollBar().minimum()
        hscroll_max = self.horizontalScrollBar().maximum() - \
                      hscroll_min
        vscroll_min = self.verticalScrollBar().minimum()
        vscroll_max = self.verticalScrollBar().maximum() - \
                      vscroll_min
        self.horizontalScrollBar().setValue(hscroll_min + hscroll_max / 2)
        self.verticalScrollBar().setValue(vscroll_min + vscroll_max / 2)

    def rotate_widget(self, degree):
        """
        Поворачивает центральное изображение на degree градусов
        """
        self.rotation += degree
        # сброс счётчика при полном повороте
        if self.rotation >= 360 or self.rotation <= -360:
            self.rotation = 0
            return

        # работа объекта-трансформатора
        self.transform.rotate(self.rotation)
        self.transform.translate(-self.current_img_width / 2, -self.current_img_height / 2)
        self.img_item.setTransform(self.transform)

        scene_width, scene_height = self.compute_scene()

        self.setSceneRect(-scene_width / 2,
                          -scene_height / 2,
                          scene_width,
                          scene_height
                          )

        self.transform.reset()

    def compute_scene(self):
        """
        Расчёт размера сцены
        """
        flip = False
        angle = math.fabs(self.rotation)

        if angle == 0 or angle == 180:
            scene_width = self.current_img_width
            scene_height = self.current_img_height

        elif angle == 90 or angle == 270:
            scene_width = self.current_img_height
            scene_height = self.current_img_width

        else:
            # для зеркального решения
            if angle > 180:
                angle -= 180

            if angle > 90:
                angle -= 90
                flip = True

            radians = math.radians(angle)

            width_a = self.current_img_height * math.sin(radians)
            width_b = self.current_img_width * math.cos(radians)

            height_a = self.current_img_width * math.sin(radians)
            height_b = self.current_img_height * math.cos(radians)

            scene_width = width_a + width_b
            scene_height = height_a + height_b

            if flip is True:
                scene_width, scene_height = scene_height, scene_width

        return scene_width, scene_height

    def check_pixmap(self, pixmap):
        """
        Проверка возможности открытия картинки
        Возвращает True, если картинку открыть можно
        Возвращает False, если открыть картинку не получится
        """
        if pixmap.isNull() == True:
            print('mopyqtiv: ошибка открытия изображения {0}'.format(pixmap.path),
                  '\nmopyqtiv: попытка открыть следующее изображение'
                  )
            # если открыть не удаётся, тут же пробует открыть следующее изображение
            self.main.next_image()
            # если битое изображение не поменялось, значит картинок больше нет
            if pixmap.path == self.main.current_image:
                print('mopyqtiv: не удаётся найти изображения в папке')
                sys.exit(0)

            # удаление файла нечитаемой картинки из списка изображений текущей папки
            try:
                self.main.filer.files.remove(pixmap.path)
            except ValueError:
                pass

            return False
        else:
            return True

    def full_size_image_scale(self):
        """
        Возвращает значение масштаба изображения для текущего размера окна,
        при котором картинка примет масштаб 1:1 с сохранением попорций
        """
        coefficient_x = 0
        coefficient_y = 0

        if self.current_pixmap.width() > self.main.frame_resolution_width:
            coefficient_x = self.current_pixmap.width() / self.main.frame_resolution_width
        if self.current_pixmap.height() > self.main.frame_resolution_height:
            coefficient_y = self.current_pixmap.height() / self.main.frame_resolution_height

        return max(coefficient_x, coefficient_y)

    def is_current_scale_bigger_than_frame(self):
        """
        Возвращает True, если хотя бы одна из сторон изображения
        больше, чем текущий размер окна
        Возвращает False, если размер изображения полностью помещается
        в текущие габариты окна
        """
        if self.current_img_width > self.main.frame_resolution_width \
                or self.current_img_height > self.main.frame_resolution_height:
            return True
        else:
            return False

    def set_image_full_size(self):
        """
        Устанавливает размер текущего изображения до 1:1
        """
        scale = self.full_size_image_scale()
        self.set_image(self.main.current_image, scale)

    def increase_in_size(self):
        """
        Увеличивает размер текущего изображения
        на один шаг, равный SCALE_STEP
        """
        if self.current_scale < 10:
            self.current_scale += SCALE_STEP
            self.set_image(self.main.current_image, self.current_scale)

    def scale_back(self):
        """
        Уменьшает размер текущего изображения
        на один шаг, равный SCALE_STEP
        """
        if self.current_scale > 0.5:
            self.current_scale -= SCALE_STEP
            self.set_image(self.main.current_image, self.current_scale)

    def magnifier(self):
        """
        Режим «Лупа»
        Масштаб зависит от глобальной переменной SCALE_MAGNIFIER
        """
        self.is_scaled = False
        self.is_magnified = True
        self.set_image(self.main.current_image, SCALE_MAGNIFIER)
        self.magnifier_move()

    def magnifier_move(self):
        """
        Обработка перемещения в режиме «лупа»
        """
        hscroll_min = self.horizontalScrollBar().minimum()
        hscroll_max = self.horizontalScrollBar().maximum() - \
                      hscroll_min
        vscroll_min = self.verticalScrollBar().minimum()
        vscroll_max = self.verticalScrollBar().maximum() - \
                      vscroll_min
        scroll_step_x = hscroll_max / 100
        scroll_step_y = vscroll_max / 100
        mouse_step_x = self.main.frame_resolution_width / 100 / \
                       MAGNIFIER_MOVE_BOOST
        mouse_step_y = self.main.frame_resolution_height / 100 / \
                       MAGNIFIER_MOVE_BOOST
        step_x = QCursor.pos().x() / mouse_step_x
        step_y = QCursor.pos().y() / mouse_step_y

        self.horizontalScrollBar().setValue(hscroll_min + step_x * scroll_step_x)
        self.verticalScrollBar().setValue(vscroll_min + step_y * scroll_step_y)

    def context_menu(self, point):
        """
        Вызвает выпадающее меню
        """
        self.main.popup.file = self.main.current_image
        self.main.popup.exec_(QCursor.pos())

    def mousePressEvent(self, event):
        """
        Обработка нажатий кнопок мыши
        """
        # обработка щелчка левой кнопки мыши
        if event.buttons() == Qt.LeftButton:
            self.lb_held = True
            # запуск режима лупы
            if self.is_scaled is not True \
                    or self.is_current_scale_bigger_than_frame() is False:
                self.setDragMode(QGraphicsView.NoDrag)
                self.magnifier()
                self.main.try_hand_cursor(event)

            # обработка перемещения увеличенного изображения
            if self.is_scaled is True:
                self.setDragMode(QGraphicsView.ScrollHandDrag)
                self.main.try_hand_cursor(event)
                QGraphicsView.mousePressEvent(self, event)

        # установка изображения в полный размер при нажатии на колёсико
        if event.buttons() == Qt.MiddleButton:
            self.lb_held = True
            # если изображение способно к увеличению в полный размер
            if self.is_scaled is False \
                    and self.full_size_image_scale() > 1.0:
                self.setDragMode(QGraphicsView.ScrollHandDrag)
                self.set_image_full_size()
                self.main.try_hand_cursor(event)

            # обработка выхода из режима увеличения
            elif self.is_scaled is True:
                self.setDragMode(QGraphicsView.NoDrag)
                self.is_scaled = False
                self.set_image(self.main.current_image, self.scale_default)
                self.set_img_center()
                self.main.try_hand_cursor(event)

            # если изображение неспособно к полному размеру - ничего не делать
            else:
                return

        # обработка щелчка правой кнопки мыши
        if event.buttons() == Qt.RightButton:
            self.rb_held = True

    def mouseMoveEvent(self, event):
        """
        Обработка событий перемещения картинки в режиме «лупа»
        """
        if self.is_magnified is True:
            self.magnifier_move()

        elif self.is_scaled is True:
            QGraphicsView.mouseMoveEvent(self, event)

        # появление панели миниатюр в зависимости от положения курсора мыши
        if qApp.mouseButtons() != Qt.LeftButton:
            # 20 - кол-во пикселей от правого края,
            # заходя за которые курсором мыши, появится панель миниатюр
            if QCursor.pos().x() > self.main.pos().x() + self.main.frame_resolution_width - 20:
                self.main.miniatures_scroller.show()
            if QCursor.pos().x() < self.main.pos().x() + self.main.frame_resolution_width - \
                    self.main.miniature_current_width:
                self.main.miniatures_scroller.hide()

    def mouseReleaseEvent(self, event):
        """
        Обработка снятия щелчка кнопок мыши
        """
        if event.button() == Qt.LeftButton:
            if self.is_scaled is True:
                self.setDragMode(QGraphicsView.NoDrag)
                self.main.try_hand_cursor(event)

            elif self.is_magnified is True:
                self.set_image(self.main.current_image,
                               self.scale_default
                               )
                self.set_img_center()
                self.main.try_hand_cursor(event)

        if event.button() == Qt.RightButton:
            if self.rb_combined is True:
                pass

            elif self.rb_combined is False:
                self.context_menu(QCursor.pos())

        # сброс комбинации
        self.lb_held = False
        self.rb_held = False
        self.rb_combined = False

    def wheelEvent(self, event):
        """
        Для стабильности обработки колесика мыши
        """
        self.main.wheelEvent(event)


class MainWindow(QWidget):
    """
    Виджет главного окна
    Связующий класс
    """

    def __init__(self, start_image):
        super().__init__()

        self.binds = []
        self.is_image_altered = False
        self.current_image = os.path.abspath(start_image)
        self.program_icon = QIcon.fromTheme('pixelart-trace')
        self.trash_path = os.path.expanduser('~') + '/.local/share/Trash'
        self.miniature_current_width = MINIATURE_WIDTH
        self.screen_resolution = QApplication.desktop().screenGeometry()

        # для корректировки размера миниатюр
        self.coefficient = 1.0

        # размер рабочей области
        self.frame_resolution_width = self.screen_resolution.width()
        self.frame_resolution_height = self.screen_resolution.height()

        # доступные клавиши для привязывания сортировочных папок
        self.keys_for_bindings = (Qt.Key_Z, Qt.Key_X, Qt.Key_C, Qt.Key_V, Qt.Key_B,
                                  Qt.Key_N, Qt.Key_M, Qt.Key_A, Qt.Key_S, Qt.Key_D,
                                  Qt.Key_F, Qt.Key_G, Qt.Key_H, Qt.Key_J, Qt.Key_K,
                                  Qt.Key_L, Qt.Key_W, Qt.Key_E, Qt.Key_R, Qt.Key_T,
                                  Qt.Key_Y, Qt.Key_U, Qt.Key_I, Qt.Key_O, Qt.Key_P)

        # включает режим отслеживания положения мыши
        self.setMouseTracking(True)

        # настройка главного окна
        self.main_palette = QPalette()  # палитра главного окна
        self.setAutoFillBackground(True)  # позволяет установить фон QWidget
        self.background_color = QColor()
        self.background_color.setNamedColor(BACKGROUND_COLOR)
        self.set_background(self.background_color)
        self.change_title(os.path.split(start_image)[1])
        self.setFocusPolicy(Qt.StrongFocus)

        # раскрывает главное окно на весь экран
        self.move(0, 0)
        self.resize(self.frame_resolution_width, self.frame_resolution_height)

        # установка иконки приложения
        self.setWindowIcon(self.program_icon)

        # главное окно без рамки
        if WITHOUT_BORDER is True:
            self.setWindowFlags(Qt.FramelessWindowHint)

        # создание экземпляров классов
        self.filer = Filer()
        self.info = InfoLabel(self)
        self.popup = PopupMenu(self)
        self.imageviewer = ImageViewer(self)
        self.miniatures_area = MiniaturesArea(self)
        self.miniatures_handler = MiniaturesHandler(self)
        self.miniatures_scroller = MiniaturesScroller(self)

        # настройка области прокрутки панели миниатюр
        self.miniatures_scroller.focusNextPrevChild(True)
        self.miniatures_scroller.hide()

        # создаёт список картинок из текущей папки
        self.filer.list_folder(self.filer.current_folder)

        # создание и установка миниатюр
        self.miniatures_handler.set_miniatures()

        # регистрация функции удаления временных файлов при выходе
        atexit.register(self.at_close)

    def frame_ratio(self):
        """
        Возвращает коэффициент отношения сторон текущего окна
        """
        return self.frame_resolution_width / self.frame_resolution_height

    def set_background(self, color):
        """
        Установка фона главного окна
        """
        self.main_palette.setColor(QPalette.Background, color)
        self.setPalette(self.main_palette)

    def change_title(self, name):
        """
        Изменяет заголовок окна
        """
        self.setWindowTitle('Mouse oriented PyQt5 image viewer: {0}'.format(name))

    def trash(self, file_path):
        """
        Отправляет указанную картинку в корзину
        """
        # TODO: удаление для оффтопика
        if os.path.isdir(self.trash_path):

            # при переносе в корзину текущего изображения
            if file_path == self.current_image \
                    and file_path != self.filer.files[-1]:
                self.next_image()

            for_delete_full_path = file_path
            for_delete_file_name = os.path.split(for_delete_full_path)[1]

            # перемещение файла в корзину
            destination = self.trash_path + '/files/' + for_delete_file_name
            shutil.move(for_delete_full_path, destination)

            # создание файла описания удалённого файла
            date = time.strftime('%Y-%m-%dT%H:%M:%S', time.localtime(time.time()))
            info_file = self.trash_path + '/info/' + for_delete_file_name + '.trashinfo'
            info = '[Trash Info]\nPath={0}\nDeletionDate={1}\n'.format(for_delete_full_path, date)
            with open(info_file, 'w') as info_file:
                info_file.write(info)

            # удаление файла картинки из списка изображений текущей папки
            try:
                self.filer.files.remove(for_delete_full_path)
            except ValueError:
                pass

            # удаление его миниатюры
            self.miniatures_handler.purge_miniature(for_delete_full_path)

            self.info.show_hint('Файл «{0}» перемещен в корзину'.format(for_delete_file_name))

            if for_delete_full_path == self.current_image:
                self.next_image()

    def next_image(self):
        """
        Установка следующего в списке изображения
        """
        try:
            current_index = self.filer.files.index(self.current_image)
        # если файл отсутствует в списке изображений, пробует открыть последнее
        except ValueError:
            current_index = -1

        # если изображение в папке нет -> выход
        if len(self.filer.files) == 0:
            print('mopyqtiv: не удаётся найти изображения в папке')
            sys.exit(0)

        # если всё нормально -> следующее изображение
        if current_index <= len(self.filer.files) - 2:
            self.current_image = self.filer.files[current_index + 1]
        else:
            self.current_image = self.filer.files[-2]

        self.imageviewer.set_image(self.current_image,
                                   self.imageviewer.scale_default
                                   )

    def previous_image(self):
        """
        Установка предыдующего в списке изображения
        """
        try:
            current_index = self.filer.files.index(self.current_image)
        # если файл отсутствует в списке изображений -> выход
        except ValueError:
            current_index = 0

        if len(self.filer.files) == 0:
            print('mopyqtiv: не удаётся найти изображения в папке')
            sys.exit(0)

        # если всё нормально -> предыдующее изображение
        if current_index > 0:
            self.current_image = self.filer.files[current_index - 1]
            self.imageviewer.set_image(self.current_image, self.imageviewer.scale_default)

    def turn_image(self, image_path, degree):
        """
        Поворачивает изображение image_path
        в зависимости от параметра degree
        """
        try:
            with Image.open(image_path) as image:
                image = image.rotate(degree, resample=Image.BICUBIC, expand=True)
                image.save(image_path)
        except OSError:
            self.info.show_hint('Не удалось повернуть изображение. '
                                'Возможно, у Вас недостаточно прав на файл')

    def turn_right(self, image_path):
        """
        Вращает изобажение image_path и его миниатюру вправо
        """
        self.turn_image(image_path, -90)
        self.is_image_altered = True
        self.imageviewer.set_image(image_path, self.imageviewer.scale_default)
        self.miniatures_handler.turn_miniature(image_path, -90)

    def turn_left(self, image_path):
        """
        Вращает изобажение image_path и его миниатюру влево
        """
        self.turn_image(image_path, 90)
        self.is_image_altered = True
        self.imageviewer.set_image(image_path, self.imageviewer.scale_default)
        self.miniatures_handler.turn_miniature(image_path, 90)

    def choose_file(self):
        """
        Запускает диалог выбора изображения
        """
        if self.filer.can_choose_file is False:
            print('mopyqtiv: Вы не можете выбирать изображения,\n',
                  '\tпока создаются миниатюры для текущей папки'
                  )

            return

        file_path = self.filer.choose_file()

        if file_path == '':
            return

        self.filer.current_folder = os.path.split(file_path)[0]
        self.current_image = file_path
        self.filer.list_folder(self.filer.current_folder)
        self.imageviewer.set_image(file_path, self.imageviewer.scale_default)
        self.miniatures_handler.purge_all_miniatures()
        self.miniatures_handler.set_miniatures()
        self.filer.can_choose_file = False

    def bind_key(self, key):
        """
        Привязывает на клавишу путь до папки (выбирается через диалог)
        """
        bind = Bind()
        bind.key = key()
        bind.path = self.filer.choose_folder(os.getcwd())

        if bind.path == '':
            return
        else:
            self.binds.append(bind)
            self.info.show_hint('Клавиша привязана к «{0}»'.format(bind.path))

    def unbind_key(self, key):
        """
        Отвязывает папку от клавиши
        """
        for bind in self.binds:
            if bind.key == key():
                self.binds.remove(bind)
                self.info.show_hint('Клавиша освобождена')

    def work_bind(self, event):
        """
        Обрабатывает привязку/отвязку папок от клавиш,
        а также перемещение изображений
        """
        for bind in self.binds:
            if event.key() == bind.key \
                    and event.modifiers() == Qt.NoModifier:
                bind.move(self.current_image)

                # уведомление о перемещении
                file_name = os.path.split(self.current_image)[1]
                self.info.show_hint('Файл «{0}» перемещен в «{1}»'.format(
                        file_name, bind.path)
                )

                self.miniatures_handler.purge_miniature(self.current_image)
                path_for_remove = self.current_image
                self.next_image()
                self.filer.files.remove(path_for_remove)
                return

        if event.modifiers() == Qt.NoModifier:
            self.bind_key(event.key)

        elif event.modifiers() == Qt.ControlModifier:
            self.unbind_key(event.key)

    def try_hand_cursor(self, event):
        """
        Меняет указатель мыши стрелку на руку,
        если картинка больше габаритов окна, и наоборот
        """
        # в режиме «лупа»
        if self.imageviewer.is_magnified is True:
            self.setCursor(Qt.BlankCursor)
            return

        # в режиме перетаскивания
        if self.imageviewer.is_current_scale_bigger_than_frame() is True \
                and event.buttons() == Qt.LeftButton:
            self.setCursor(Qt.ClosedHandCursor)
            return

        # в режиме готовности к перетаскиванию
        if self.imageviewer.is_current_scale_bigger_than_frame() is True \
                and self.imageviewer.is_scaled is True:
            self.setCursor(Qt.OpenHandCursor)
            return

        # во всех остальных случаях
        else:
            self.setCursor(Qt.ArrowCursor)

    def keyPressEvent(self, event):
        """
        Обработка нажатий клавиш клавиатуры
        """
        if event.key() == Qt.Key_Right or event.key() == Qt.Key_Down:
            self.next_image()

        if event.key() == Qt.Key_Left or event.key() == Qt.Key_Up:
            self.previous_image()

        # поворот изображения
        if event.modifiers() == Qt.ControlModifier \
                and event.key() == Qt.Key_R:
            self.turn_right(self.current_image)

        if event.modifiers() == Qt.ControlModifier \
                and event.key() == Qt.Key_L:
            self.turn_left(self.current_image)

        if event.key() == Qt.Key_Delete:
            self.trash(self.current_image)

        if event.key() == Qt.Key_Backspace:
            self.choose_file()

        if event.key() == Qt.Key_Escape or event.key() == Qt.Key_Q:
            sys.exit(0)

        # обработчик сортировки по горячим клавишам
        if event.key() in self.keys_for_bindings:
            self.work_bind(event)

    def mouseMoveEvent(self, event):
        """
        Страховка от потери фокуса для панели миниатюр
        """
        self.imageviewer.mouseMoveEvent(event)

    def wheelEvent(self, event):
        """
        Настройка комбинаций с колёсиком мыши
        """
        step = event.angleDelta().y()  # -120 колёсико на себя, 120 - от себя
        if self.miniatures_scroller.isVisible() is True:
            return

        # увеличение масштаба колёсиком мыши + ConrolModifier
        elif step > 0 and event.modifiers() == Qt.ControlModifier:
            self.imageviewer.increase_in_size()
            self.try_hand_cursor(event)

        # увеличение масштаба колёсиком мыши + LeftButton
        elif step > 0 and self.imageviewer.rb_held is True:
            self.imageviewer.increase_in_size()
            self.try_hand_cursor(event)
            self.imageviewer.rb_combined = True

        # уменьшение масштаба колёсиком мыши + ConrolModifier
        elif step < 0 and event.modifiers() == Qt.ControlModifier:
            self.imageviewer.scale_back()
            self.try_hand_cursor(event)

        # уменьшение масштаба колёсиком мыши + RightButton
        elif step < 0 and self.imageviewer.rb_held is True:
            self.imageviewer.scale_back()
            self.try_hand_cursor(event)
            self.imageviewer.rb_combined = True

        # вращение изображения + ShiftModifier
        elif step > 0 and event.modifiers() == Qt.ShiftModifier:
            self.imageviewer.rotate_widget(-ROTATE_STEP)
            self.try_hand_cursor(event)

        # вращение изображения + ShiftModifier
        elif step < 0 and event.modifiers() == Qt.ShiftModifier:
            self.imageviewer.rotate_widget(ROTATE_STEP)
            self.try_hand_cursor(event)

        # вращение изображения + LeftButton
        elif step > 0 and self.imageviewer.lb_held is True:
            self.imageviewer.rotate_widget(-ROTATE_STEP)
            self.try_hand_cursor(event)

        # вращение изображения + LeftButton
        elif step < 0 and self.imageviewer.lb_held is True:
            self.imageviewer.rotate_widget(ROTATE_STEP)
            self.try_hand_cursor(event)

        # если модификаторов не зажато
        else:
            if step > 0:
                self.previous_image()

            else:
                if self.current_image != self.filer.files[-1]:
                    self.next_image()
                else:
                    return

            # восстановление курсора
            self.setCursor(Qt.ArrowCursor)

    def resizeEvent(self, event):
        """
        Срабатывает при изменении размера окна
        """
        # настройка основной картинки
        self.frame_resolution_width = self.frameSize().width()
        self.frame_resolution_height = self.frameSize().height()

        #  подготовка центрального виджета
        self.imageviewer.move(0, 0)
        self.imageviewer.resize(
                self.frame_resolution_width,
                self.frame_resolution_height
        )
        self.imageviewer.set_image(self.current_image, self.imageviewer.scale_default)

        # настройка размера и положения миниатюр
        self.coefficient = self.frameSize().width() / self.screen_resolution.width()
        self.miniature_current_width = self.coefficient * MINIATURE_WIDTH
        self.miniatures_handler.resize_miniatures(self.coefficient)
        self.miniatures_scroller.move(
                self.frame_resolution_width -
                (self.miniature_current_width + 36), 0
        )

        # 36: компенсатор размера прокрутки
        self.miniatures_scroller.resize(self.miniature_current_width + 36,
                                        self.frame_resolution_height
                                        )

    def at_close(self):
        """
        Очистка временной папки с миниатюрами при выходе
        """
        self.miniatures_handler.miniatures_folder_handler.remove_miniatures_folder()


def mopyqtiv_help():
    print('\nmopyqtiv - программа для просмотра изображений, написанная на python,'
          '\nс использованием библиотек PyQt пятой серии и PIL.'
          '\nДля подробной справки:'
          '\n\tman mopyqtiv'
          '\n\nИспользование:'
          '\n\tmopyqtiv [-h] [файл]'
          '\n\t-h\tключ для показа этого сообщения'
          '\n\tфайл\tпрограмма может открыть изображения следующих форматов:'
          '\n\t\t*.bmp *.pbm *.pgm *.ppm *.xbm *.xpm *.jpg *.jpeg *.png *.gif')


if __name__ == '__main__':
    if '-h' in sys.argv:
        mopyqtiv_help()
        sys.exit(0)

    elif len(sys.argv) > 2 or len(sys.argv) < 2:
        print('Для запуска приложения mopyqtiv укажите открываемое изображение.',
              '\nДля справки запустите с параметром -h')
        sys.exit(0)

    else:
        first, second = Pipe()
        app = QApplication(sys.argv)
        mainwindow = MainWindow(sys.argv[1])
        mainwindow.show()
        sys.exit(app.exec_())
